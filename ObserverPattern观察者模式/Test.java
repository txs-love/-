package example.Design.ObserverPattern观察者模式;

/**
 * @author txssherry@gmail.com
 * @date 2023/3/26 16:28
 */
public class Test {
    /**
     * 观察者模式在实际项目的应用中非常常见，比如你到 ATM 机器上取钱，多次输错密码，卡就会被 ATM
     * 吞掉，吞卡动作发生的时候，会触发哪些事件呢？第一摄像头连续快拍，第二，通知监控系统，吞卡发生；
     * 第三，初始化 ATM 机屏幕，返回最初状态，你不能因为就吞了一张卡，整个 ATM 都不能用了吧，一般前两
     * 个动作都是通过观察者模式来完成的。
     *
     *
     *  观察者模式有一个变种叫做发布/订阅模型（Publish/Subscribe），如果你做过 EJB（Enterprise
     * JavaBean）的开发，这个你绝对不会陌生。EJB2 是个折腾死人不偿命的玩意儿，写个 Bean 要实现，还要继
     * 承，再加上那一堆的配置文件，小项目还凑活，你要知道用 EJB 开发的基本上都不是小项目，到最后是每
     * 个项目成员都在骂 EJB 这个忽悠人的东西；但是 EJB3 是个非常优秀的框架，还是算比较轻量级，写个 Bean
     * 只要加个 Annotaion 就成了，配置文件减少了，而且也引入了依赖注入的概念，虽然只是 EJB2 的翻版，但
     * 是毕竟还是前进了一步，不知道以后 EJB 的路会怎么样。在 EJB 中有三个类型的 Bean: Session Bean、Entity
     * Bean 和 MessageDriven Bean,我们这里来说一下 MessageDriven Bean（一般简称为 MDB），消息驱动 Bean，
     * 消息的发布者(Provider)发布一个消息，也就是一个消息驱动 Bean,通过 EJB 容器（一般是 Message Queue
     * 消息队列）通知订阅者做出回应，从原理上看很简单，就是观察者模式的升级版。
     *  那观察者模式在什么情况下使用呢？观察者可以实现消息的广播，一个消息可以触发多个事件，这是
     * 观察者模式非常重要的功能。使用观察者模式也有两个重点问题要解决：
     * 广播链的问题。如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表 A 上写了
     * 一个触发器，内容是一个字段更新后更新表 B 的一条数据，而表 B 上也有个触发器，要更新表 C，表 C 也有
     *
     * 触发器…,完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双
     * 重身份，即使观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护
     * 性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消
     * 息最多转发一次（传递两次），这还是比较好控制的；
     * 异步处理问题。这个 EJB 是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察
     * 者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个
     * 大家有时间看看 Message Queue，就会有更深的了解。
     * 我们在来回顾一下我们写的程序，观察者增加了，我就必须修改业务逻辑 Client 程序，这个是必须得
     * 吗？回顾一下我们以前讲到工厂方法模式的时候用到了 ClassUtils 这个类，其中有一个方法就是根据接口
     * 查找到所有的实现类，问题解决了吧！我可以查找到所有的观察者，然后全部加进来，以后要是新增加观
     * 察者也没有问题呀，程序那真是一点都不用改了！
     * @param args
     */
    public static void main(String[] args) {

    }
}
