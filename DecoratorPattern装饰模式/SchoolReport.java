package example.Design.DecoratorPattern装饰模式;

/**
 * @author txssherry@gmail.com
 * @date 2023/3/26 9:40
 */

/**
 * 装饰模式是对继承的有力补充，你要知道继承可不是万能的，继承可以解决实际的问题，但是在项目
 * 中你要考虑诸如易维护、易扩展、易复用等，而且在一些情况下（比如上面那个成绩单例子）你要是用继
 * 承就会增加很多了类，而且灵活性非常的差，那当然维护也不容易了，也就是说装饰模式可以替代继承，
 * 解决我们类膨胀的问题，你要知道继承是静态的给类增加功能，而装饰模式则是动态的给增加功能，你看
 * 上面的那个例子，我不想要 SortDecorator 这层的封装也很简单呀，直接在 Father 中去掉就可以了，如果
 * 你用继承就必须修改程序。
 * 装饰模式还有一个非常好的优点，扩展性非常好，在一个项目中，你会有非常多因素考虑不到，特别
 * 是业务的变更，时不时的冒出一个需求，特别是提出一个令项目大量延迟的需求时候，那种心情是…，真
 * 想骂娘！装饰模式可以给我们很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成，
 */
public abstract class SchoolReport {    //成绩单
    //成绩单的主要展示的就是你的成绩情况
    public abstract void report();

    //成绩单要家长签字，这个是最要命的
    public abstract void sign(String name);
}
